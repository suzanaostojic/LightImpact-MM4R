import pandas as pd
import numpy as np

# Load and Prepare WLTP data
# File should include: 'Time','Speed','Acceleration'
df = pd.read_csv("WLTP data/Time-Speed-Profile_WLTP_Class3b.csv") 
df["v"] = df["Speed (km/h)"] * (1000/3600) # velocity data, convert to m/s
df["a"] = df["Acceleration (m/s2)"] # acceleration data [m/s2]
df["dt"] = df["Time (s)"].diff().fillna(1) # time steps dt [s]

df_tractive = df[(df["a"] > 0) & (df["v"] > 0)].copy() # filter for positve tractive phases (a > 0, v > 0)
df_braking = df[(df["a"] < 0) & (df["v"] > 0)].copy() # filter for negative braking phases (a < 0, v > 0)

# Constants and Parameters
m_ref             = 100.0        # standard reference mass [kg] used for calculation
ds_ref            = 100.0        # standard reference distance [km] used for calculation
g                 = 9.81         # gravitational acceleration [m/s2]
f_R               = 0.01         # rolling-resistance coefficient [-]
f_Rot             = 0.10         # rotational mass factor [-]
rho_air           = 1.2          # air density [kg/m3]
cw                = 0.30         # drag coefficient [-]
A_frontal         = 2.07         # vehicle frontal area [m²]
ds                = 23.26        # distance covered by WLTC class 3b [km]
roll_pos_factor   = 0.55         # share of rolling‐res during positive-tractive phase [-]
mu                = 0.30         # regenerative-braking efficiency [-]

# Mechanical Work Integrals ICV 
W_R = (m_ref * g * f_R * ds * 1000) / 1e6  # Rolling resistance Work [MJ]

a_v_integral = np.sum(df_tractive["a"] * df_tractive["v"] * df_tractive["dt"]) # Positive traction phases integral a*v*dt [m²/s²]
W_A = m_ref * a_v_integral / 1e6 # Acceleration Work [MJ]
W_Rot = m_ref * f_Rot * a_v_integral / 1e6 # Rotational Work [MJ]

# Mechanical Work Integrals EV
W_R_brake = (m_ref * g * f_R * ds * 1000) / 1e6 # Rolling resistance Work [MJ]
a_v_brake_integral = np.sum(df_braking["a"] * df_braking["v"] * df_braking["dt"]) # Negative braking phases integral a*v*dt [m²/s²]
W_A_brake = m_ref * a_v_brake_integral / 1e6
W_Rot_brake = m_ref * f_Rot * a_v_brake_integral / 1e6
v3_integral = np.sum(df_braking["v"]**3 * df_braking["dt"])
W_L_brake = (rho_air / 2) * cw * A_frontal * v3_integral / 1e6

# Total mechanical Work for ICV
W_mech_ICV_100kg_100km = (roll_pos_factor * W_R + W_A + W_Rot) * (ds_ref / ds)
print(f"Total mechanical work (ICV, 100kg, 100km): {W_mech_ICV_100kg_100km:.4f} MJ")

# Total mechanical Work for EV
E_b = abs(W_R_brake + W_A_brake + W_Rot_brake + W_L_brake)
denominator = m_ref * np.sum(df_tractive["a"] * df_tractive["v"] * df_tractive["dt"])
phi = E_b / denominator # braking energy to kinetic energy ratio

W_A_EV = W_A * (1 - phi * mu)
W_mech_EV_100kg_100km = (roll_pos_factor * W_R + W_A_EV + W_Rot) * (ds_ref / ds)
print(f"Total mechanical work (EV, 100kg, 100km):  {W_mech_EV_100kg_100km:.4f} MJ")
